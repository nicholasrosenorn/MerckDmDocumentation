
# Data Engineering Fall 2020 Documentation

## Table of Contents
### Team Introduction
### Semester Goals
### Overview of Data
### Scaling the Framework
#### Multiple Users
#### Multiples Devices
### Scheduling the Data Collection
### Collaborating with other Teams
### Future Work

## Introduction to the Team- everyone

Our data engineering team is comprised of 6 team members all with unique skills and backgrounds. The team worked hard to utilize each member's strengths to help accomplish the semester goals for this project. 

Include a brief sentence including your name, major, year, and relevant experience to the data mine.

Jennifer Leising: I am a graduate student in Industrial Engineering. My research is focused on healthcare and data analytics, and I have experience working in Clinical trials for a large Pharma company. 
Eric Yap: I am sophomore majoring in data science and finance. Most of my classes have helped developed my Python and R skills, which are very transferable to the work I do in the data mine.
Allison Hill: I am a senior majoring in electrical engineering. I have coding experience in various languages, including some Python and R which were used within this project.


## Semester Goals - Pranav

Include a brief overview of the project scope and the data engineering's role within the project. 
Also include our team's semester's goals.

## Data Overview - Jennifer



Discuss Apple vs Fitbit data available 
Discuss what type of data was included in our scope
Discuss potential ideas for data cleaning and handling missing data

## Scaling the Framework

The framework for collecting biometric data from Fitbit's API was previously established and can be found in the [Merck Wearables Book section 8](https://nicholasrosenorn.github.io/wearables-book/tutorial-data-capture-in-python.html#authentication). However, this framework could only be used to collect one user's data at a time, and needed to be manually monitored to switch between browser and python windows. Further, the framework assumed that the user's Fitbit device would be the Fitbit Ionic. In order to make this project upscalable, the framework needed to be modified to support multiple users in an automizable way and the program needed to account for multiple device types. 

### Multiple Users - Joshua

#### Supporting Multiple Users Via Accessing Credentials
To support multiple users, a database of multiple user login credentials needed to be created. There is an ongoing collaboration with the Front End team to create a more secure storage system, but for now credentials are stored in a csv file with the format "username,password". With the usernames and passwords stored in this way, a login array can be created that will be used to plug into the automated process.

```{python}
# Initialize Emails and Passwords lists
Emails = []
Passwords = []

# Create Emails and Passwords lists from Fitbit_Credentials.csv
with open("Fitbit_Credentials.csv") as File1:
    IDs = csv.DictReader(File1)
    for row in IDs:
        Emails.append(row['Username'])
        Passwords.append(row['Password'])
```
As previously mentioned, the previous framework was not set up for running through multiple accounts. To solve this issue, it was reformatted into iterative-friendly components. The first of which is the PythonBot.py file, which both establishes the login arrays outlined above and is responsible for coordinating the other file and function calls to make this process run smoothly. 

```{python}
# import other codes
import BiometricPrevious
import gather_keys_oauth2 as Oauth2

class FitbitBot:
    def __init__(self, EMAIL, PASSWORD, DATE):

        #Both the Client ID and Client Secret come from when Fitbit site after registering an app
        CLIENT_ID = '22BH28' 
        CLIENT_SECRET = '78a4838804c1ff0983591e69196b1c46'
        
        #Authorization Process
        server = Oauth2.OAuth2Server(CLIENT_ID, CLIENT_SECRET)
        server.browser_authorize(EMAIL, PASSWORD)

        ACCESS_TOKEN = str(server.fitbit.client.session.token['access_token'])
        REFRESH_TOKEN = str(server.fitbit.client.session.token['refresh_token'])
        auth2_client = fitbit.Fitbit(CLIENT_ID, CLIENT_SECRET, Oauth2=True, access_token=ACCESS_TOKEN,
        refresh_token=REFRESH_TOKEN)
        BiometricPrev = BiometricPrevious.FitbitModel1(auth2_client)
        
        biometricDF = BiometricPrev.getBiometricData(DATE) #append to data frame
        biometricDF.to_csv('./user' + str(i) + '_' + DATE + '.csv')
        print("Python Script Executed")

# Run data extraction
for i in range(len(Emails)):
    for j in range(1): # Call the previous 1 days worth of info <-- will be replaced with cronjob
        today = str((datetime.datetime.now() - datetime.timedelta(j)).strftime("%Y-%m-%d"))
        FitbitBot(Emails[i], Passwords[i], today)
```
The *BiometricPrevious* file contains the remainder of the previous framework with data collection functions, but it was also altered to allow for multiple devices. More information about his can be found in the **Multiple Devices** section of this report. 

The line *biometric.to_csv* will store the collected data in a csv format with a title of *user#_DATE*, where *user#* corresponds to the order at which the user's login credentials are stored in the credentials csv database.  

#### Supporting Multiple Users Via Allowing for Automation

In order to create an automation bot to regularly call the data collection code (see **Scheduling Our Data Collection** for more information on this), the code had to be adjusted so that it did not open browser windows, as this opening of browser windows was found to stall the bot. In order to accomplish this, the Selenium module was used. Official Selenium documentation can be found [here](https://selenium-python.readthedocs.io).

Since Selenium was not already downloaded on the device, it needed to be installed. To do this, the following was typed into a Terminal window:

```{python}
pip install selenium
```

To use Selenium in a code, the libraries and packages will need to be imported. Since gather_keys_oauth2 is the code package responsible for accessing websites, it only needs to be imported in this document. To do this, the following code was added to *gather_keys_oauth2.py*.

```{python}
from selenium import webdriver
from selenium.webdriver import Firefox
from selenium.webdriver.firefox.options import Options
from selenium.webdriver.common.by import By
```

Strictly speaking, the only explicitly needed code would be *import Selenium*. However, by importing specific functions from the Selenium library upfront, notation later on was simpler. This can be seen below when firefox options were set. Instead of calling *Selenium.webdriver.firefox.options* every line, we can simply called *Options*. 

The appropriate Selenium firefox browser driver was downloaded [here](https://github.com/mozilla/geckodriver/releases). Though it did not matter where the driver was installed, its installation path needs to be plugged into the gather_keys_oath2.py code. For those following along with guide, make a note of this installation path.

The following block of code was written to set the Selenium webdriver functions.

```{python}
firefox_options = Options()
firefox_options.add_argument("window-size=1920,1080")
firefox_options.add_argument("--headless")
firefox_options.add_argument("start-maximized")
firefox_options.add_argument("--disable-infobars")
firefox_options.add_argument("--disable-extensions")
firefox_options.add_argument("--no-sandbox")
firefox_options.add_argument("--disable-dev-shm-usage")
firefox_options.binary_location = '/class/datamine/apps/firefox/firefox'
```
Adjust the path in the final option, *firefox_options.binary_location*, accordingly. 

The other main option of interest was *firefox_options.add_argument("--headless")*. This *headerless* option is what allows the code to access the Fitbit website without actually opening a browser -- effectively, Python becomes a browswer simulator, and is the main reason Selenium was used. The first time an account is added, manual permissions will need to be granted to Fitbit's authorization website. To do this, comment out this headerless option and check the permissions boxes for each new account. After doing this once, uncomment this headerless line. The system will then be set for automization. The other options are for optimal performance, but not strictly necessary. 

The official Selenium documentation also supports a Google Chrome driver. If Chrome is preferred, it can be substituted in for FireFox without issue. However, make sure to change all instances of *firefox* in the above codes to *Chrome.*

With Selenium downloaded and imported, the last step was to call and use Selenium. The following line in *browser_authorize* function in *gather_keys_oauth2.py* was responsible for opening the webbrowser, so it was targetted for edits. 

```{python}
    threading.Timer(1, webbrowser.open, args=(url,)).start()
```

As its name might suggest, the *webbrowser.open* function causes a webbrowser to open. The other passed arguments *1* and *args=(url,)* are parameters that can be left unchanged. This line was replaced with the following code: 

```{python}
    driver = webdriver.Firefox(executable_path = '/class/datamine/apps/geckodriver', options=firefox_options)
    driver.get("https://accounts.fitbit.com/login?targetUrl=https%3A%2F%2Fwww.fitbit.com%2Fus%2Fhome")
    sleep(5)
    driver.find_element(By.XPATH, "//input[@type='email']").send_keys(email)
    sleep(2)
    driver.find_element(By.XPATH, "//input[@type='password']").send_keys(password)
    sleep(2)
    driver.find_element(By.XPATH, "/html/body/div[2]/div/div[2]/div/div/div[3]/form/div[4]/div/button").click()
    sleep(10)
    
    threading.Timer(1, driver.get, args=(url,)).start()
```

The first line of the following code initializes the Selenium webdriver. Edit the *executable_path* as needed based on where the firefox driver was installed. The next line, *driver.get*, tells the Selenium webbrowser what website to go to. The *find_elements* commands are what allow for the automization of plugging in usernames and emails. The sleep functions are input time delays to help make sure that the website has time to properly load before attempting to log in. The final line should look familiar. It is the same as the original line, except replacing the *webbrowser.open*, which opens a normal web browser, with *driver.get*, which calls Selenium's browser simulater. The rest of *gather_keys_oauth2* can remain as is.


### Multiple Devices - Allison
Not all fitbit devices have the same data available to them. This is most noticeable in older models, in which functionality such as the number of floors climbed or sleep cycles was not yet implemented. Using the get_Devices function available in the Fitbit API, the code returns a string corresponding to the Fitbit version. For example, a Fitbit Ionic would return the string "Ionic". Using this information, if-else statements were implemented to check the version and assign corresponding data values. Data that is not available would be input as "None" within the data table. In some cases, the function can simply check if the data is NULL and automatically do this such as with the sleep data. However for data such as activity levels, the data gets input as a "0" instead and thus needs a check. Checks for some of the newer models have been implemented, along with a generic case. The table below shows the implemented models and their available data:
                |                                       |Ionic         | Versa Lite  |Inspire      |Charge 3     |
 ---------------|---------------------------------------|--------------|-------------|-------------|-------------|
 Activity       |Steps                                  |X             |X            |X            |X            |
                |Workouts                               |X             |X            |             |             |
                |Sit/Stand                              |X             |X            |             |             |
                |Flight Climbed                         |X             |             |             |             |
                |Elevation                              |X             |             |             |             |
                |Time spent in different activity levels|X             |X            |             |             |
                |Calories burned                        |X             |X            |             |             |
 Sleep          |Asleep vs Awake                        |X             |X            |X            |X            |
                |Stages                                 |X             |X            |             |             |
 Heart Rate     |Time spent in different heart ranges   |X             |X            |             |X            |
                |Resting heart rate                     |X             |X            |             |X            |
                |Walking Heartrate                      |X             |X            |             |X            |
                |Heart rate during activity             |X             |X            |             |X            |
 ---------------------------------------------------------------------------------------

## Scheduling the Data Collection - Eric

Through using the CronTab module within Python, we are able to schedule and run our FitBit functions on a routinely basis. The data we collect is stored in a dataframe and new data is continuously appended to this dataframe. The scheduled time is set to every 9 AM on weekdays.



## Collaborating with other Teams - Karthik

## Future Work - Jennifer

Include: streamlining our work with the other groups (see above); Potentially changing the way we are accessing the user’s fitbit info; Apple watch data collection


