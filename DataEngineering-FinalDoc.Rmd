
# Data Engineering Fall 2020 Documentation

## Table of Contents
### Team Introduction
### Semester Goals
### Overview of Data
### Scaling the Framework
#### Multiple Users
#### Multiples Devices
### Scheduling the Data Collection
### Collaborating with other Teams
### Future Work

## Introduction to the Team- everyone

Our data engineering team is comprised of 6 team members all with unique skills and backgrounds. The team worked hard to utilize each member's strengths to help accomplish the semester goals for this project. 

Include a brief sentence including your name, major, year, and relevant experience to the data mine.

Jennifer Leising: I am a graduate student in Industrial Engineering. My research is focused on healthcare and data analytics, and I have experience working in Clinical trials for a large Pharma company. 
Eric Yap: I am sophomore majoring in data science and finance. Most of my classes have helped developed my Python and R skills, which are very transferable to the work I do in the data mine.
Allison Hill: I am a senior majoring in electrical engineering. I have coding experience in various languages, including some Python and R which were used within this project.


## Semester Goals - Pranav

Include a brief overview of the project scope and the data engineering's role within the project. 
Also include our team's semester's goals.

## Data Overview - Jennifer



Discuss Apple vs Fitbit data available 
Discuss what type of data was included in our scope
Discuss potential ideas for data cleaning and handling missing data

## Scaling the Framework

The framework for collecting biometric data from Fitbit's API was previously established and can be found in the [Merck Wearables Book section 8](https://nicholasrosenorn.github.io/wearables-book/tutorial-data-capture-in-python.html#authentication). However, this framework could only be used to collect one user's data at a time, and needed to be manually monitored to switch between browser and python windows. Further, the framework assumed that the user's Fitbit device would be the Fitbit Ionic. In order to make this project upscalable, the framework needed to be modified to support multiple users in an automizable way and the program needed to account for multiple device types. 

### Multiple Users - Joshua

#### Supporting Multiple Users Via Accessing Credentials
To support multiple users, a database of multiple user login credentials needed to be created. There is an ongoing collaboration with the Front End team to create a more secure storage system, but for now credentials are stored in a csv file with the format "username,password". With the usernames and passwords stored in this way, a login array can be created that will be used to plug into the automated process.

```{python}
# Initialize Emails and Passwords lists
Emails = []
Passwords = []

# Create Emails and Passwords lists from Fitbit_Credentials.csv
with open("Fitbit_Credentials.csv") as File1:
    IDs = csv.DictReader(File1)
    for row in IDs:
        Emails.append(row['Username'])
        Passwords.append(row['Password'])
```
As previously mentioned, the previous framework was not set up for running through multiple accounts. To solve this issue, it was reformatted into iterative-friendly components. The first of which is the PythonBot.py file, which both establishes the login arrays outlined above and is responsible for coordinating the other file and function calls to make this process run smoothly. 

```{python}
# import other codes
import BiometricPrevious
import gather_keys_oauth2 as Oauth2

class FitbitBot:
    def __init__(self, EMAIL, PASSWORD, DATE):

        #Both the Client ID and Client Secret come from when Fitbit site after registering an app
        CLIENT_ID = '22BH28' 
        CLIENT_SECRET = '78a4838804c1ff0983591e69196b1c46'
        
        #Authorization Process
        server = Oauth2.OAuth2Server(CLIENT_ID, CLIENT_SECRET)
        server.browser_authorize(EMAIL, PASSWORD)

        ACCESS_TOKEN = str(server.fitbit.client.session.token['access_token'])
        REFRESH_TOKEN = str(server.fitbit.client.session.token['refresh_token'])
        auth2_client = fitbit.Fitbit(CLIENT_ID, CLIENT_SECRET, Oauth2=True, access_token=ACCESS_TOKEN,
        refresh_token=REFRESH_TOKEN)
        BiometricPrev = BiometricPrevious.FitbitModel1(auth2_client)
        
        biometricDF = BiometricPrev.getBiometricData(DATE) #append to data frame
        biometricDF.to_csv('./user' + str(i) + '_' + DATE + '.csv')
        print("Python Script Executed")

# Run data extraction
for i in range(len(Emails)):
    for j in range(1): # Call the previous 1 days worth of info <-- will be replaced with cronjob
        today = str((datetime.datetime.now() - datetime.timedelta(j)).strftime("%Y-%m-%d"))
        FitbitBot(Emails[i], Passwords[i], today)
```
The BiometricPrevious file contains the remainder of the previous framework with data collection functions, but it was also altered to allow for multiple devices. More information about his can be found in the Multiple Devices section of this report. 

The line biometric.to_csv will store the collected data in a csv format with a title of user#_DATE, where user# corresponds to the order at which the user's login credentials are stored in the credentials csv database.  

#### Supporting Multiple Users Via Allowing for Automation

In order to create an automation bot to regularly call the data collection code (see Scheduling Our Data Collection for more information on this), the code had to be adjusted so that it did not open browser windows, as this opening of browser windows was found to stall the bot. In order to accomplish this, the Selenium module was used. Official Selenium documentation can be found [here](https://selenium-python.readthedocs.io).

Unless Selenium is already downloaded on the device, it will need to be installed. To do this, open a Terminal window and type:

```{python}
pip install selenium
```

Download the appropriate firefox browser driver [here](https://github.com/mozilla/geckodriver/releases). Make a note of its installation path. Though it does not matter where it is installed, its location will need to be plugged into the gather_keys_oath2.py code. To plug in this location, locate the following firefox_options at the top of the code:
```{python}
firefox_options = Options()
firefox_options.add_argument("window-size=1920,1080")
firefox_options.add_argument("--headless")
firefox_options.add_argument("start-maximized")
firefox_options.add_argument("--disable-infobars")
firefox_options.add_argument("--disable-extensions")
firefox_options.add_argument("--no-sandbox")
firefox_options.add_argument("--disable-dev-shm-usage")
firefox_options.binary_location = '/class/datamine/apps/firefox/firefox'
```
Adjust the path in the final option, *firefox_options.binary_location*, accordingly. 

The other main option of interest is *firefox_options.add_argument("--headless")*. This *headerless* option is what allows the code to access the Fitbit website without actually opening a browser -- effectively, Python becomes a browswer simulator, and is the main reason Selenium was used. The other options are for optimal performance, but not strictly necessary. 



### Multiple Devices - Allison
Not all fitbit devices have the same data available to them. This is most noticeable in older models, in which functionality such as the number of floors climbed or sleep cycles was not yet implemented. Using the get_Devices function available in the Fitbit API, the code returns a string corresponding to the Fitbit version. For example, a Fitbit Ionic would return the string "Ionic". Using this information, if-else statements were implemented to check the version and assign corresponding data values. Data that is not available would be input as "None" within the data table. In some cases, the function can simply check if the data is NULL and automatically do this such as with the sleep data. However for data such as activity levels, the data gets input as a "0" instead and thus needs a check. Checks for some of the newer models have been implemented, along with a generic case. The table below shows the implemented models and their available data:
                |                                       |Ionic         | Versa Lite  |Inspire      |Charge 3     |
 ---------------|---------------------------------------|--------------|-------------|-------------|-------------|
 Activity       |Steps                                  |X             |X            |X            |X            |
                |Workouts                               |X             |X            |             |             |
                |Sit/Stand                              |X             |X            |             |             |
                |Flight Climbed                         |X             |             |             |             |
                |Elevation                              |X             |             |             |             |
                |Time spent in different activity levels|X             |X            |             |             |
                |Calories burned                        |X             |X            |             |             |
 Sleep          |Asleep vs Awake                        |X             |X            |X            |X            |
                |Stages                                 |X             |X            |             |             |
 Heart Rate     |Time spent in different heart ranges   |X             |X            |             |X            |
                |Resting heart rate                     |X             |X            |             |X            |
                |Walking Heartrate                      |X             |X            |             |X            |
                |Heart rate during activity             |X             |X            |             |X            |
 ---------------------------------------------------------------------------------------

## Scheduling the Data Collection - Eric

Through using the CronTab module within Python, we are able to schedule and run our FitBit functions on a routinely basis. The data we collect is stored in a dataframe and new data is continuously appended to this dataframe. The scheduled time is set to every 9 AM on weekdays.



## Collaborating with other Teams - Karthik

## Future Work - Jennifer

Include: streamlining our work with the other groups (see above); Potentially changing the way we are accessing the user’s fitbit info; Apple watch data collection


